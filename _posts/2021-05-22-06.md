---
layout: post
title: 자바 람다함수-2(5)
tags: [java, lambda]
category: 'Java'
image: /assets/img/Java-logo.png
---

어제 람다함수로 익명구현객체를 만드는 것을 보고 궁금한게 생겼다.

추상 메소드의 파라미터가 객체인 경우에는 람다함수식을 표현한 상태에서 객체의 멤버 변수에 접근할 수 있을까?

그래서 익명구현객체 오버라이딩 메소드 파라미터가 객체인 코드를 짜보았다.
<br><br>
```
@FunctionalInterface
interface UseObject {
    void feed(Object object);
}
// main 메소드 안
UseObject useObject = (obj)->{
    System.out.println(obj.name + "에게 밥을 먹였습니다");
};
useObject.feed(new Animal("사자"));
```
<br><br>
이렇게 했더니 obj.name에서 name을 찾을 수 없다는 컴파일 오류가 났다. 파라미터의 obj 앞에 Animal 을 명시해줘도 여전히 오류가 났다.

근데 이제 밑의 코드는 돌아간다
<br><br>
```
@FunctionalInterface
interface UseObject {
    void feed(Animal object);
}
// main 메소드 안
UseObject useObject = (obj)->{
    System.out.println(obj.name + "에게 밥을 먹였습니다");
};
useObject.feed(new Animal("사자"));
```
<br><br>
인터페이스에서 명시적으로 알려줘야 코드가 동작하는 것 같다.
근데 내가 feed 안에 넣고 싶은 매개변수가 다양할 수도 있는데, 이럴 때에는 어떡하지?

그래서 comparator 인터페이스를 람다함수를 이용해 구현하는 것을 살펴보았다.
<br><br>
```
Collections.sort(players, (a,b)-> b.getScore()-a.getScore());
```
<br><br>
이 코드에서는 a,b가 객체임에도 정확히 명시를 안해주고있다. 그래서 Comparator 의 인터페이스도 보았다
<br><br>
```
public interface Comparator <T> {
    int compare(T o1, T o2);
}
```
<br><br>
제네릭을 통해 클래스 옆에 명시를 해주고 있다.

그래서 나도 이것을 참고해 코드를 바꾸었다.
<br><br>
```
@FunctionalInterface
interface UseObject<T> {
    void feed(T object);
}

UseObject useObject = (obj)->{
            System.out.println(obj.name + "에게 밥을 먹였습니다");
        };
        useObject.feed(new Animal("사자"));
```

<br><br>
여전히 obj.name 에서 오류가 난다..
 

왜지? 다음에 알아보도록 하자..
